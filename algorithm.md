---
title: clrs算法整理
---

## 正文

### 排序算法与查找

#### 插排              
* theta(n2)
 
#### 归并排序          
* theta(n*lgn)
  
#### 堆排             
* O(n*lgn)                    

* 常用于调整进程优先队列
 
#### 快排             
* theta(nlgn)                 

* 最常用的大数列排序

#### 计数排序          
* theta(k+n)                  

* 用于取值范围紧凑的数列排序
 
#### 基数排序           
* theta(d(n+k))               

* 对多关键字域的记录排序
 
#### 桶排序            
* theta(n)                    

* 数据分布较均匀的数据

#### 线性查找　　　　　　

* theta(n)            

#### 优化的线性查找     

* 最坏theta(n)                

* 利用子区间中位数进行分割



### 散列表

#### 链接法散列表         
* theta(1+alpha)              

* 不错的查找速度，较灵活的插入和删除

#### 开放寻址法散列表      
* theta(1/(1-alpha))          

* 优秀的查找速度，对删除操作支持不好

#### 完全散列            
* theta(1)                    

* 极好的查找速度，建表慢，一旦建好，不支持对表结构改变


### 树

#### 普通二叉树
* search, minimum, maximum, successor, predecessor, insert, delete的运行时间位O(h)，　h为树高。

* 随机构建的二叉树，树高h期望为O(lgn)


####　红黑树

* 红黑树是平衡树，树高为O(lgn)

* search, minimum, maximum, successor, predecessor操作同普通二叉树

* insert和delete较复杂，但时间度也仅为O(lgn)

###  数据结构的扩张

#### 例子：　order static red and black tree

#### 例子：　interval red and black tree

#### 扩张数据结构的一般步骤:

 * 选择一种基础数据结构
 * 确定基础数据结构中要维护的附加信息
 * 检验基础数据结构上的基本修改操作能否维护附加信息
 * 设计一些新的操作

###　高级设计与分析

#### 动态规划的一般步骤

* 刻画一个最优解的结构特征

* 递归地定义最优解的值

* 计算最优解的值，通常采用自底向上的方法

* 利用计算出的信息构造一个最优解

#### 发掘最优子结构

* 证明问题最优解的第一个做出一个选择。做出这次选择会产生一个或多个待解的子问题

* 对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择会得到最优解。

* 给定可选择最优解的选择后，你确定这次选择会产生哪些子问题，遗迹如何更好地刻画子问题空间。

* 利用“cut-and-paste”技术证明:作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。

#### 重叠子问题

* 这是适合动态规划方法求解的最优化问题的第二个性质。

* 子问题空间必须足够"小"，即问题的递归算法会反复地求解相同的自问题，而不是一直生成新的子问题。

#### 例子

* 钢条切割　r[n] = p[i] + r[n-i]

* 矩阵链乘法 m[i, j] = m[i, k] + m[k + 1, j] + p[i-1] * p[k] * p[j])

* 最长公共子序列 c[i,j]={c[i-1, j-1] + 1 if: i,j>0 and x[i]==y[j]} 
or {max(c[i,j-1], c[i-1,j]) if: i,j>0 and x[i] != y[i]}

* 最长二叉搜索树 e[i, j] = e[i, r-1] + e[r + 1, j] + w(i, j)

####　贪心算法的一般步骤

* 确定问题的最优子结构

* 设计一个递归算法

* 证明如果我们做出一个贪心选择，则只剩下一个子问题

* 证明贪心选择总是安全的

* 设计一个递归算法实现贪心策略

* 将递归算法转换为迭代算法

####　例子

* 活动选择问题 c[i, j] = max{c[i, k] + c[k, j] + 1}

* hoffman编码:　每步策略:将频率最低的两个字符合成为一个字符求解新的hoffman树

#### 怎样分辨一个问题适用贪心算法还是动态规划算法

* 这个问题是否可以在不进行后续决策的情况下判断出当前的最优决策。

#### 拟阵的三条性质(拟阵M=(S, I)的判定)

* S是一个有限集

* I是S子集的非空族，这些子集称为S的独立子集，使得如果B∈I且A⊆B，则A∈I。称I为遗传的。

* 若A∈I, B∈I且|A|<|B|,那么存在某个元素x∈B-A，使得A∪{x}∈I，称M满足交换性质。

#### 拟阵的两个例子

* 图拟阵

* 矩阵拟阵

####　具体应用例子

* 最小生成树问题转化为加权拟阵最大权重独立子集问题，用贪心算法求解。

* 单位时间任务调度问题(最小化延迟任务惩罚=最大化提前任务惩罚值和)

#### 摊还分析

##### amortized analysis

* 循环部分的复杂度并非每步复杂度的简单加和，聚合分析可以给出更紧密的上界。

##### accounting method

* 赋予某些操作(栈操作中的push, 二进制计数器中的置位操作)多于其实际代价的费用，以支付后续操作的费用。

* 初始积累费用可能不为零(栈中初始有元素/计数器初始不为0)，　这些仅仅是常数项，不影响复杂度分析。

* 总的摊还代价(加上初始的费用积累(这是常数项，可略去))是总的实际代价的一个上界。

##### potential method

* 引入势能的概念，每个操作的摊还代价=实际代价+势能变化

* 只要保证整个过程势能变化为正值，总的摊还代价是总的实际代价的一个上界

* 势能的例子:(栈操作中的元素数量，计数器中1的数量)

* 势能法可以用于计算初始状态势能不为0的情况。在这种情况下，我们不能保证“整个过程势能变化为正值”，但是，由于我们已经建立起总的实际代价、总的势能变化和总的摊还代价(引入势能变化，可以将每步摊还代价设为常数值)的关系，我们可以通过作为已知量总的势能变化和总的摊还代价来求出总的实际代价。

##### 例子:动态表

* 注意书中的分析过程，是以基本insert操作为1代价的(意味着allocate, free作为低阶复杂度的操作，其代价被忽略了)

* 可以再仔细看看动态表的势能模型，和insert, delete操作的摊还分析的计算过程。

### 高级数据结构

#### B树

* 用于管理磁盘内容。


#### 斐波那契堆

* 良好的瘫痪时间复杂度

* extract_min 和 delete: O(lgn)

* make_heap, insert, minimum, extract_min, union, decrease_key, delete: O(1)复杂度

* 一些图问题算法可能频繁调用decrease_key。一些问题(如最小生成树和寻找单源最短路径)的快速算法必不可少地要用到斐波那契堆。

* 实际上，斐波那契堆的常数因子和编程复杂性使得它较普通二项堆不太适用。

* 二项堆和斐波那契堆对search支持不好。


#### van Emde Boas树

* 限制关键字为0 ~ u-1的整数，　且无重复

* search, insert, delete, minimum, maximum, successor, predecessor运行时间位O(lglgu)

#### 用于不相交集合的数据结构

*　两种启发式策略(union by rank) 和　(path compression)的一并使用，极大地改善了disjoint_set forest上各操作的时间复杂度

* 对于n个元素的个不相交集合操作，改进后的运行时间是O(m*alpha(n))

#### 其他高级数据结构

* 动态树

* 伸展树

* 持久数据结构

* 聚合树

* 动态图数据结构


### 图算法

#### 基本图算法

* bfs, dfs的时间复杂度皆为O(V + E)

* bfs用于寻找最短路径

* dfs用于拓扑排序、寻找强连通分量








